// <auto-generated/>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.InteropServices;

namespace SchedulerCommon.NativeMethods
{
     public static class UnsafeNativeMethods
     {
        public const uint CREATE_NEW_CONSOLE = 0x00000010;
        public const uint CREATE_UNICODE_ENVIRONMENT = 0x00000400;

        [StructLayout(LayoutKind.Sequential)]
        struct WTS_SESSION_INFO
        {
            public Int32 SessionID;

            [MarshalAs(UnmanagedType.LPStr)]
            public String pWinStationName;

            public WTS_CONNECTSTATE_CLASS State;
        }

        enum WTS_CONNECTSTATE_CLASS
        {
            WTSActive,
            WTSConnected,
            WTSConnectQuery,
            WTSShadow,
            WTSDisconnected,
            WTSIdle,
            WTSListen,
            WTSReset,
            WTSDown,
            WTSInit
        }

        enum LockState
        {
            Locked = 0,
            Unlocked = 1,
            Unknown = 0xFFFFFF
        }

        [StructLayout(LayoutKind.Sequential)]
        struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct SECURITY_ATTRIBUTES
        {
            public int nLength;
            public IntPtr lpSecurityDescriptor;
            public bool bInheritHandle;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct STARTUPINFO
        {
            public Int32 cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwYSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        enum WTS_INFO_CLASS
        {
            WTSInitialProgram,
            WTSApplicationName,
            WTSWorkingDirectory,
            WTSOEMId,
            WTSSessionId,
            WTSUserName,
            WTSWinStationName,
            WTSDomainName,
            WTSConnectState,
            WTSClientBuildNumber,
            WTSClientName,
            WTSClientDirectory,
            WTSClientProductId,
            WTSClientHardwareId,
            WTSClientAddress,
            WTSClientDisplay,
            WTSClientProtocolType,
            WTSIdleTime,
            WTSLogonTime,
            WTSIncomingBytes,
            WTSOutgoingBytes,
            WTSIncomingFrames,
            WTSOutgoingFrames,
            WTSClientInfo,
            WTSSessionInfo,
            WTSSessionInfoEx,
            WTSConfigInfo,
            WTSValidationInfo,
            WTSSessionAddressV4,
            WTSIsRemoteSession
        };

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct WTSINFOEX_LEVEL1
        {
            public uint SessionId;
            public WTS_CONNECTSTATE_CLASS SessionState;
            public int SessionFlags;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 33)]
            public string WinStationName;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 21)]
            public string UserName;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 18)]
            public string DomainName;
            public Int64 LogonTime;
            public Int64 ConnectTime;
            public Int64 DisconnectTime;
            public Int64 LastInputTime;
            public Int64 CurrentTime;
            public uint IncomingBytes;
            public uint OutgoingBytes;
            public uint IncomingFrames;
            public uint OutgoingFrames;
            public uint IncomingCompressedBytes;
            public uint OutgoingCompressedBytes;
        };

        [StructLayout(LayoutKind.Explicit)]
        struct WTSINFOEX_LEVEL
        {
            [FieldOffset(0)]
            public WTSINFOEX_LEVEL1 WTSInfoExLevel1;
        };

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        struct WTSINFOEX
        {
            public uint Level;
            public WTSINFOEX_LEVEL Data;
        };

        [DllImport("wtsapi32.dll", SetLastError = true)]
        static extern Int32 WTSEnumerateSessions(
            IntPtr hServer,
            [MarshalAs(UnmanagedType.U4)] Int32 Reserved,
            [MarshalAs(UnmanagedType.U4)] Int32 Version,
            ref IntPtr ppSessionInfo,
            [MarshalAs(UnmanagedType.U4)] ref Int32 pCount);

        [DllImport("wtsapi32.dll", ExactSpelling = true, SetLastError = false)]
        static extern void WTSFreeMemory(IntPtr memory);

        [DllImport("wtsapi32.dll", SetLastError = true)]
        static extern bool WTSQueryUserToken(UInt32 sessionId, out IntPtr Token);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern UInt32 WaitForSingleObject(IntPtr handle, UInt32 milliseconds);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        static extern bool GetExitCodeProcess(IntPtr hProcess, out uint lpExitCode);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool CloseHandle(IntPtr hSnapshot);

        [DllImport("userenv.dll", SetLastError = true)]
        private static extern bool CreateEnvironmentBlock(out IntPtr lpEnvironment, IntPtr hToken, bool bInherit);

        [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        static extern bool CreateProcessAsUser(
            IntPtr hToken,
            string lpApplicationName,
            string lpCommandLine,
            ref SECURITY_ATTRIBUTES lpProcessAttributes,
            ref SECURITY_ATTRIBUTES lpThreadAttributes,
            bool bInheritHandles,
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            string lpCurrentDirectory,
            ref STARTUPINFO lpStartupInfo,
            out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("Wtsapi32.dll", SetLastError = true)]
        static extern bool WTSQuerySessionInformation(IntPtr hServer, uint sessionId, WTS_INFO_CLASS wtsInfoClass, out IntPtr ppBuffer, out uint pBytesReturned);

        static List<WTS_SESSION_INFO> ListSessionsInfo()
        {
            IntPtr WTS_CURRENT_SERVER_HANDLE = (IntPtr)null;
            List<WTS_SESSION_INFO> ret = new List<WTS_SESSION_INFO>();

            try
            {
                IntPtr ppSessionInfo = IntPtr.Zero;
                Int32 count = 0;
                Int32 retval = WTSEnumerateSessions(WTS_CURRENT_SERVER_HANDLE, 0, 1, ref ppSessionInfo, ref count);
                Int32 dataSize = Marshal.SizeOf(typeof(WTS_SESSION_INFO));
                Int64 current = (Int64)ppSessionInfo;

                if (retval != 0)
                {
                    for (int i = 0; i < count; i++)
                    {
                        WTS_SESSION_INFO si = (WTS_SESSION_INFO)Marshal.PtrToStructure((System.IntPtr)current, typeof(WTS_SESSION_INFO));
                        current += dataSize;

                        ret.Add(si);
                    }

                    WTSFreeMemory(ppSessionInfo);
                }
            }
            catch (Exception ex)
            {
                Globals.Log.Error(ex.Message);
            }

            return ret;
        }

        static List<uint> ListSessionId()
        {
            List<WTS_SESSION_INFO> lSessions = ListSessionsInfo();

            List<uint> IDs = new List<uint>();

            foreach (WTS_SESSION_INFO si in lSessions)
            {
                if (si.State == WTS_CONNECTSTATE_CLASS.WTSActive)
                {
                    IDs.Add(((uint)si.SessionID));
                }
            }

            return IDs;
        }

        static uint InjectProcessAsUser(UInt32 sessionID, string sExe, string Args, bool WaitForExit)
        {
            uint ExitCode = 0;
            int err = 0;

            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            STARTUPINFO si = new STARTUPINFO();

            pi.dwProcessId = -1;
            pi.dwThreadId = -1;
            pi.hProcess = IntPtr.Zero;
            pi.hThread = IntPtr.Zero;

            si.cb = Marshal.SizeOf(si);
            si.lpDesktop = "WinSta0\\Default";

            IntPtr uToken = new IntPtr();

            if (!WTSQueryUserToken(sessionID, out uToken))
            {
                err = Marshal.GetLastWin32Error();
                throw new Win32Exception(err);
            }

            SECURITY_ATTRIBUTES saProcessAttributes = new SECURITY_ATTRIBUTES();
            SECURITY_ATTRIBUTES saThreadAttributes = new SECURITY_ATTRIBUTES();

            saProcessAttributes.nLength = Marshal.SizeOf(saProcessAttributes);
            saThreadAttributes.nLength = Marshal.SizeOf(saThreadAttributes);

            IntPtr envBlock = IntPtr.Zero;

            uint dwCreationFlags = CREATE_UNICODE_ENVIRONMENT | CREATE_NEW_CONSOLE;

            CreateEnvironmentBlock(out envBlock, uToken, false);

            if (!CreateProcessAsUser(uToken, sExe, $" {Args}", ref saProcessAttributes, ref saThreadAttributes, false, dwCreationFlags, envBlock, null, ref si, out pi))
            {
                err = Marshal.GetLastWin32Error();
                throw new Win32Exception(err);
            }

            if (pi.hProcess != IntPtr.Zero && WaitForExit)
            {
                WaitForSingleObject(pi.hProcess, 999999999);
                GetExitCodeProcess(pi.hProcess, out ExitCode);
            }

            if (uToken != null)
                CloseHandle(uToken);

            return ExitCode;
        }

        public static int Run(string Exe, string Arg, bool WaitForExit)
        {
            List<uint> SessionsIDs = ListSessionId();

            if (SessionsIDs.Count > 0)
            {
               return (int) InjectProcessAsUser(SessionsIDs[0], Exe, Arg, WaitForExit);
            }

            return 9999;
        }

        public static bool IsUserLoggedOn()
        {
            uint iReturned = 0;
            IntPtr pAddress = IntPtr.Zero;
            var sLoggedOnUserName = string.Empty;
            uint SessionID = 0;

            List<uint> SessionsIDs = ListSessionId();

            if (SessionsIDs.Count > 0)
            {
                SessionID = SessionsIDs[0];
            }
            else
            {
                return false;
            }

            try
            {
                if (WTSQuerySessionInformation(IntPtr.Zero, SessionID, WTS_INFO_CLASS.WTSUserName, out pAddress, out iReturned) == true)
                {
                    sLoggedOnUserName = Marshal.PtrToStringAnsi(pAddress);
                    WTSFreeMemory(pAddress);
                }
            }
            catch (Exception ex)
            {
                Globals.Log.Error(ex.Message);
            }

            return !string.IsNullOrEmpty(sLoggedOnUserName);
        }

        public static bool IsSessionLocked()
        {
            var retVal = true;

            uint iReturned = 0;
            IntPtr ppBuffer = IntPtr.Zero;
            var sLoggedOnUserName = string.Empty;
            uint SessionID = 0;

            List<uint> SessionsIDs = ListSessionId();

            if (SessionsIDs.Count > 0)
            {
                SessionID = SessionsIDs[0];
            }
            else
            {
                return retVal;
            }

            try
            {
                if (WTSQuerySessionInformation(IntPtr.Zero, SessionID, WTS_INFO_CLASS.WTSSessionInfoEx, out ppBuffer, out iReturned) == true)
                {
                    var session_info_ex = Marshal.PtrToStructure<WTSINFOEX>(ppBuffer);
                    var lockState = session_info_ex.Data.WTSInfoExLevel1.SessionFlags;
                    retVal = lockState != (int)LockState.Unlocked;

                    WTSFreeMemory(ppBuffer);
                }
            }
            catch (Exception ex)
            {
                Globals.Log.Error(ex.Message);
            }

            return retVal;
        }
    }
}
